from app.service.facebook_api import fb_get, send_message, send_image_binary, send_video_binary
from fastapi.responses import JSONResponse, HTMLResponse, RedirectResponse
from datetime import datetime
import requests
from fastapi import APIRouter, Response, Request, Depends
from sqlalchemy.orm import Session
from app.database import crud, schemas, database, models
from app.database.database import get_db
from app import config  # ‚úÖ ‡πÉ‡∏ä‡πâ config ‡πÅ‡∏ó‡∏ô app.app
from pydantic import BaseModel
from typing import Optional
from app.config import image_dir,vid_dir
from app.service.message_scheduler import message_scheduler



router = APIRouter()

# ================================
# üîß ‡πÄ‡∏û‡∏¥‡πà‡∏° Memory Storage ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Page Tokens
# ================================
# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏ô facebook.py ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö paste.txt
page_tokens = {}  # key = page_id, value = PAGE_ACCESS_TOKEN
page_names = {}   # key = page_id, value = page_name

class SendMessageRequest(BaseModel):
    message: str
    type: Optional[str] = "text"  # "text", "image", or "video"

@router.get("/connect", response_class=HTMLResponse)
async def connect_facebook_page():
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Facebook Page</title>
        <meta charset="utf-8">
        <style>
            body {{
                font-family: Arial, sans-serif;
                text-align: center;
                margin-top: 100px;
                background-color: #f0f2f5;
            }}
            a.button {{
                background-color: #4267B2;
                color: white;
                padding: 14px 24px;
                text-decoration: none;
                font-size: 18px;
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }}
            a.button:hover {{
                background-color: #365899;
            }}
        </style>
    </head>
    <body>
        <h1>‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Facebook Page ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</h1>
        <p>‡∏Ñ‡∏•‡∏¥‡∏Å‡∏õ‡∏∏‡πà‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠</p>
        <a href="{config.OAUTH_LINK}" class="button">üîó ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Facebook</a>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)

@router.get("/facebook/callback")
def facebook_callback(code: str, db: Session = Depends(get_db)):
    print(f"üîó Facebook callback received with code: {code[:20]}...")
    
    # ‡∏î‡∏∂‡∏á access token
    token_url = "https://graph.facebook.com/v14.0/oauth/access_token"
    params = {
        "client_id": config.FB_APP_ID,
        "redirect_uri": config.REDIRECT_URI,
        "client_secret": config.FB_APP_SECRET,
        "code": code
    }

    print("üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ç‡∏≠ access token...")
    res = requests.get(token_url, params=params)
    token_data = res.json()

    if "error" in token_data:
        print(f"‚ùå Error getting access token: {token_data['error']}")
        return JSONResponse(status_code=400, content={"error": token_data['error']})

    user_token = token_data.get("access_token")
    print("‚úÖ ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö user access token ‡πÅ‡∏•‡πâ‡∏ß")

    # ‡∏î‡∏∂‡∏á‡πÄ‡∏û‡∏à
    pages_url = "https://graph.facebook.com/me/accounts"
    print("üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏à...")
    pages_res = requests.get(pages_url, params={"access_token": user_token})
    pages = pages_res.json()

    if "error" in pages:
        print(f"‚ùå Error getting pages: {pages['error']}")
        return JSONResponse(status_code=400, content={"error": pages['error']})

    connected_pages = []
    for page in pages.get("data", []):
        page_id = page["id"]
        access_token = page["access_token"]
        page_name = page.get("name", f"‡πÄ‡∏û‡∏à {page_id}")
        message_scheduler.set_page_tokens(page_tokens)  # ‚úÖ ‡πÄ‡∏Å‡πá‡∏ö page_tokens ‡πÉ‡∏ô message_scheduler

        # ‚úÖ ‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô local dictionary ‡πÅ‡∏ó‡∏ô config
        page_tokens[page_id] = access_token
        page_names[page_id] = page_name

        # ‡πÄ‡∏Å‡πá‡∏ö‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢
        existing = crud.get_page_by_page_id(db, page_id)
        if not existing:
            new_page = schemas.FacebookPageCreate(page_id=page_id, page_name=page_name)
            crud.create_page(db, new_page)

        connected_pages.append({"id": page_id, "name": page_name})
        print(f"‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏û‡∏à‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {page_name} (ID: {page_id})")

    print(f"‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏û‡∏à‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î {len(connected_pages)} ‡πÄ‡∏û‡∏à")

    if connected_pages:
        return RedirectResponse(url=f"http://localhost:3000/?page_id={connected_pages[0]['id']}")
    else:
        return RedirectResponse(url="http://localhost:3000/?error=no_pages")

@router.get("/pages")
async def get_connected_pages():
    # ‚úÖ ‡πÉ‡∏ä‡πâ local dictionary ‡πÅ‡∏ó‡∏ô config
    pages_list = [{"id": k, "name": page_names.get(k, f"‡πÄ‡∏û‡∏à {k}")} for k in page_tokens.keys()]
    print(f"üìã ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏à‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: {len(pages_list)} ‡πÄ‡∏û‡∏à")
    return {"pages": pages_list}

@router.get("/psids")
async def get_user_psids(page_id: str):
    """‡∏î‡∏∂‡∏á PSID ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ"""
    print(f"üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á PSID ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}")
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ local dictionary ‡πÅ‡∏ó‡∏ô config
    access_token = page_tokens.get(page_id)
    if not access_token:
        print(f"‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö access_token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}")
        print(f"üîç Available page_tokens: {list(page_tokens.keys())}")  # Debug line
        return JSONResponse(
            status_code=400, 
            content={"error": f"‡πÑ‡∏°‡πà‡∏û‡∏ö access_token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}. ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏û‡∏à‡∏Å‡πà‡∏≠‡∏ô"}
        )
    
    print(f"‚úÖ ‡∏û‡∏ö access_token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}")
    
    conversations = get_conversations_with_participants(page_id, access_token)
    if conversations:
        data = extract_psids_with_conversation_id(conversations, access_token, page_id)
        print(f"‚úÖ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• conversations ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: {len(data)}")
        return JSONResponse(content={"conversations": data, "total": len(data)})
    else:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• conversations ‡πÑ‡∏î‡πâ")
        return JSONResponse(
            status_code=500, 
            content={"error": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• conversation ‡πÑ‡∏î‡πâ"}
        )

def get_conversations_with_participants(page_id, access_token: str = None):
    endpoint = f"{page_id}/conversations"
    params = {
        "fields": "participants,updated_time,id",
        "limit": 100
    }
    print(f"üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• conversations ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}")
    result = fb_get(endpoint, params, access_token)
    if "error" in result:
        print(f"‚ùå Error getting conversations: {result['error']}")
        return None
    print(f"‚úÖ ‡∏û‡∏ö conversations ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: {len(result.get('data', []))}")
    return result

def get_user_info_from_psid(psid, access_token):
    methods = [
        {
            "endpoint": f"{psid}",
            "params": {"fields": "name,first_name,last_name,profile_pic"}
        },
        {
            "endpoint": f"me",
            "params": {
                "fields": f"{psid}.name,{psid}.first_name,{psid}.last_name",
                "ids": psid
            }
        }
    ]

    for method in methods:
        try:
            result = fb_get(method["endpoint"], method["params"], access_token)
            if "error" not in result:
                name = result.get("name") or result.get("first_name", "")
                if name:
                    return {
                        "name": name,
                        "first_name": result.get("first_name", ""),
                        "last_name": result.get("last_name", ""),
                        "profile_pic": result.get("profile_pic", "")
                    }
        except Exception as e:
            print(f"‚ö†Ô∏è Method failed: {e}")
            continue

    fallback_name = f"User...{psid[-8:]}" if len(psid) > 8 else f"User {psid}"
    return {
        "name": fallback_name,
        "first_name": "Unknown",
        "last_name": "",
        "profile_pic": ""
    }

def get_name_from_messages(conversation_id, access_token, page_id):
    try:
        endpoint = f"{conversation_id}/messages"
        params = {
            "fields": "from,message",
            "limit": 10
        }
        result = fb_get(endpoint, params, access_token)
        if "data" in result:
            for message in result["data"]:
                sender = message.get("from", {})
                sender_name = sender.get("name")
                sender_id = sender.get("id")
                if sender_id != page_id and sender_name:
                    return sender_name
        return None
    except Exception as e:
        print(f"‚ùå Error getting name from messages: {e}")
        return None

def get_first_message_time(conversation_id, access_token):
    endpoint = f"{conversation_id}/messages"
    params = {
        "fields": "created_time",
        "limit": 1,
        "order": "chronological"
    }
    result = fb_get(endpoint, params, access_token)
    if "data" in result and result["data"]:
        return result["data"][0].get("created_time")
    return None

def extract_psids_with_conversation_id(conversations_data, access_token, page_id):
    result = []
    if not conversations_data or "data" not in conversations_data:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• conversations")
        return result

    for convo in conversations_data.get("data", []):
        convo_id = convo.get("id")
        updated_time = convo.get("updated_time")
        participants = convo.get("participants", {}).get("data", [])
        created_time = get_first_message_time(convo_id, access_token)
        user_psids = []
        user_names = []

        for participant in participants:
            participant_id = participant.get("id")
            if participant_id and participant_id != page_id:
                user_psids.append(participant_id)
                user_name = participant.get("name") or None

                if not user_name:
                    user_info = get_user_info_from_psid(participant_id, access_token)
                    user_name = user_info.get("name")

                if not user_name or user_name.startswith("User"):
                    message_name = get_name_from_messages(convo_id, access_token, page_id)
                    if message_name:
                        user_name = message_name

                if not user_name:
                    user_name = f"User...{participant_id[-8:]}"
                user_names.append(user_name)

        if user_psids:
            result.append({
                "conversation_id": convo_id,
                "psids": user_psids,
                "names": user_names,
                "updated_time": updated_time,
                "created_time": created_time
            })
    return result

@router.post("/send/{page_id}/{psid}")
async def send_user_message_by_psid(
    page_id: str,
    psid: str,
    req: SendMessageRequest,
    request: Request
):
    print(f"üì§ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á PSID: {psid}")
    print(f"üì§ ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {req.message}")

    access_token = page_tokens.get(page_id)
    if not access_token:
        return {"error": "Page token not found. Please connect via /connect first."}

    if not psid or len(psid) < 10:
        return {"error": "Invalid PSID"}

    if req.type == "image":
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á path ‡πÑ‡∏ü‡∏•‡πå local ‡πÄ‡∏ï‡πá‡∏°
        image_path = f"{image_dir}/{req.message}"
        result = send_image_binary(psid, image_path, access_token)

    elif req.type == "video":
        video_path = f"{vid_dir}/{req.message}"
        result = send_video_binary(psid, video_path, access_token)  # ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏î‡πâ‡∏ß‡∏¢

    else:
        result = send_message(psid, req.message, access_token)

    if "error" in result:
        return {"error": result["error"], "details": result}
    else:
        return {"success": True, "result": result}
# ================================
# üß™ Debug Routes - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏ß‡∏¢ Debug
# ================================

@router.get("/debug/tokens")
async def debug_tokens():
    """‡∏î‡∏π token ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ"""
    return {
        "page_tokens_count": len(page_tokens),
        "page_tokens": {k: f"{v[:20]}..." for k, v in page_tokens.items()},
        "page_names": page_names
    }

@router.get("/debug/conversations/{page_id}")
async def debug_conversations(page_id: str):
    """Debug conversations data"""
    access_token = page_tokens.get(page_id)
    if not access_token:
        return {"error": "Page token not found"}
    
    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏¥‡∏ö
    raw_conversations = get_conversations_with_participants(page_id, access_token)
    
    return {
        "page_id": page_id,
        "has_token": bool(access_token),
        "token_preview": f"{access_token[:20]}..." if access_token else None,
        "raw_data": raw_conversations
    }

# ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô facebook.py
@router.get("/conversations-with-last-message/{page_id}")
async def get_conversations_with_last_message(page_id: str):
    """‡∏î‡∏∂‡∏á conversations ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß - ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API"""
    print(f"üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• conversations ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}")
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö access token
    access_token = page_tokens.get(page_id)
    if not access_token:
        print(f"‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö access_token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}")
        return JSONResponse(
            status_code=400, 
            content={"error": f"‡πÑ‡∏°‡πà‡∏û‡∏ö access_token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page_id: {page_id}. ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏û‡∏à‡∏Å‡πà‡∏≠‡∏ô"}
        )
    
    try:
        # üî• Step 1: ‡∏î‡∏∂‡∏á conversations ‡∏û‡∏£‡πâ‡∏≠‡∏° participants ‡πÉ‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
        conversations_endpoint = f"{page_id}/conversations"
        conversations_params = {
            "fields": "participants,updated_time,id",
            "limit": 100
        }
        
        print("üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• conversations...")
        conversations_result = fb_get(conversations_endpoint, conversations_params, access_token)
        
        if "error" in conversations_result:
            print(f"‚ùå Error getting conversations: {conversations_result['error']}")
            return JSONResponse(status_code=400, content={"error": conversations_result["error"]})
        
        conversations_data = conversations_result.get("data", [])
        print(f"‚úÖ ‡∏û‡∏ö conversations ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: {len(conversations_data)}")
        
        if not conversations_data:
            return {"conversations": [], "total": 0}
        
        # üî• Step 2: ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÅ‡∏ö‡∏ö batch
        result_conversations = []
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á batch requests ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        batch_requests = []
        for i, conv in enumerate(conversations_data):
            conversation_id = conv.get("id")
            batch_requests.append({
                "method": "GET",
                "relative_url": f"{conversation_id}/messages?fields=message,from,created_time&limit=10"
            })
        
        # üöÄ ‡∏™‡πà‡∏á batch request ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
        print(f"üöÄ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á batch request ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {len(batch_requests)} conversations...")
        
        # Facebook Graph API Batch Request
        batch_url = "https://graph.facebook.com/v14.0/"
        batch_params = {
            "access_token": access_token,
            "batch": str(batch_requests).replace("'", '"')  # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô JSON string
        }
        
        import requests
        batch_response = requests.post(batch_url, data=batch_params)
        batch_results = batch_response.json()
        
        print(f"‚úÖ ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå batch request: {len(batch_results)} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£")
        
        # üî• Step 3: ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        for i, conv in enumerate(conversations_data):
            conversation_id = conv.get("id")
            updated_time = conv.get("updated_time")
            participants = conv.get("participants", {}).get("data", [])
            
            # ‡∏´‡∏≤ user participants (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà page)
            user_psids = []
            user_names = []
            
            for participant in participants:
                participant_id = participant.get("id")
                if participant_id and participant_id != page_id:
                    user_psids.append(participant_id)
                    user_name = participant.get("name")
                    
                    if not user_name:
                        user_name = f"User...{participant_id[-8:]}" if len(participant_id) > 8 else f"User {participant_id}"
                    
                    user_names.append(user_name)
            
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å batch result
            last_user_message_time = None
            first_created_time = None
            
            if i < len(batch_results) and batch_results[i].get("code") == 200:
                try:
                    import json
                    messages_data = json.loads(batch_results[i]["body"])
                    messages = messages_data.get("data", [])
                    
                    # ‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á user ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏Å‡∏™‡∏∏‡∏î
                    if messages:
                        first_created_time = messages[-1].get("created_time")  # ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏Å‡∏™‡∏∏‡∏î
                        
                        # ‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á user (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà page)
                        for message in messages:
                            sender_id = message.get("from", {}).get("id")
                            if sender_id and sender_id != page_id:
                                last_user_message_time = message.get("created_time")
                                break
                                
                except Exception as e:
                    print(f"‚ö†Ô∏è Error parsing messages for conversation {conversation_id}: {e}")
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡πÉ‡∏ô result
            if user_psids:
                user_name = user_names[0] if user_names else "‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ä‡∏∑‡πà‡∏≠"
                
                result_conversations.append({
                    "id": i + 1,
                    "conversation_id": conversation_id,
                    "conversation_name": f" {user_name}",
                    "user_name": user_name,
                    "psids": user_psids,
                    "names": user_names,
                    "raw_psid": user_psids[0],
                    "updated_time": updated_time,
                    "created_time": first_created_time,
                    "last_user_message_time": last_user_message_time  # üî• ‡πÄ‡∏ß‡∏•‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á user
                })
        
        print(f"‚úÖ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô: {len(result_conversations)} conversations ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î")
        
        return {
            "conversations": result_conversations, 
            "total": len(result_conversations),
            "optimization": "Used batch API to reduce requests"
        }
        
    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")
        return JSONResponse(
            status_code=500, 
            content={"error": f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: {str(e)}"}
        )

@router.post("/schedule/activate")
async def activate_schedule(request: Request):
    """‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô schedule"""
    data = await request.json()
    page_id = data.get('page_id')
    schedule = data.get('schedule')
    
    if not page_id or not schedule:
        return {"status": "error", "message": "Missing required data"}
    
    # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó page tokens ‡πÉ‡∏´‡πâ scheduler ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏° schedule
    message_scheduler.set_page_tokens(page_tokens)
    
    # Reset sent tracking ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö schedule ‡∏ô‡∏µ‡πâ
    schedule_id = str(schedule['id'])
    message_scheduler.sent_tracking[schedule_id] = set()
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° schedule ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏∞‡∏ö‡∏ö
    message_scheduler.add_schedule(page_id, schedule)
    
    # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ö‡∏ö‡∏™‡πà‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡πÉ‡∏´‡πâ process ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    if schedule.get('type') == 'immediate':
        await message_scheduler.process_schedule(page_id, schedule)
        return {"status": "success", "message": "Immediate schedule processed"}
    
    # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö scheduled ‡πÅ‡∏•‡∏∞ user-inactive ‡∏à‡∏∞‡∏£‡∏≠‡πÉ‡∏´‡πâ scheduler ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏•‡∏≤
    return {"status": "success", "message": "Schedule activated"}

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°:
@router.post("/test-send/{page_id}")
async def test_send_message(page_id: str, request: Request):
    """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏£‡∏á"""
    data = await request.json()
    psid = data.get('psid')
    message = data.get('message', 'Test message')
    
    access_token = page_tokens.get(page_id)
    if not access_token:
        return {"error": "No access token for this page"}
    
    result = send_message(psid, message, access_token)
    return {"result": result}

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π active schedules:
@router.get("/active-schedules/{page_id}")
async def get_active_schedules(page_id: str):
    """‡∏î‡∏π schedules ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô"""
    schedules = message_scheduler.get_active_schedules_for_page(page_id)
    return {
        "page_id": page_id,
        "active_schedules": schedules,
        "count": len(schedules)
    }

@router.post("/schedule/deactivate")
async def deactivate_schedule(request: Request):
    """‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô schedule"""
    data = await request.json()
    page_id = data.get('page_id')
    schedule_id = data.get('schedule_id')
    
    if not page_id or schedule_id is None:
        return {"status": "error", "message": "Missing required data"}
    
    message_scheduler.remove_schedule(page_id, schedule_id)
    
    return {"status": "success", "message": "Schedule deactivated"}

@router.get("/schedule/test-inactivity/{page_id}")
async def test_user_inactivity(page_id: str, minutes: int = 1):
    """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö user ‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
    
    Parameters:
    - page_id: ID ‡∏Ç‡∏≠‡∏á‡πÄ‡∏û‡∏à
    - minutes: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏≤‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö (default = 1)
    """
    # Mock schedule for testing
    test_schedule = {
        "id": 999,
        "type": "user-inactive",
        "inactivityPeriod": str(minutes),
        "inactivityUnit": "minutes",
        "groups": [1],
        "messages": [
            {
                "type": "text",
                "content": f"‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏Ñ‡∏∏‡∏ì‡∏´‡∏≤‡∏¢‡πÑ‡∏õ‡∏°‡∏≤ {minutes} ‡∏ô‡∏≤‡∏ó‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏∞‡∏Ñ‡∏∞ üòä",
                "order": 0
            },
            {
                "type": "text", 
                "content": "‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÇ‡∏°‡∏ä‡∏±‡πà‡∏ô‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì! ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡πÄ‡∏£‡∏≤‡∏™‡∏¥‡∏Ñ‡∏∞ üíù",
                "order": 1
            }
        ]
    }
    
    # Reset tracking ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    message_scheduler.sent_tracking["999"] = set()
    
    # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó page tokens ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    message_scheduler.set_page_tokens(page_tokens)
    
    # ‡∏£‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    await message_scheduler.check_user_inactivity(page_id, test_schedule)
    
    # ‡∏î‡∏∂‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
    sent_users = list(message_scheduler.sent_tracking.get("999", set()))
    
    return {
        "status": "success", 
        "message": f"Checked users inactive for {minutes} minutes",
        "sent_to_users": sent_users,
        "count": len(sent_users)
    }

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°:
@router.post("/test-send/{page_id}")
async def test_send_message(page_id: str, request: Request):
    """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏£‡∏á"""
    data = await request.json()
    psid = data.get('psid')
    message = data.get('message', 'Test message')
    
    access_token = page_tokens.get(page_id)
    if not access_token:
        return {"error": "No access token for this page"}
    
    result = send_message(psid, message, access_token)
    return {"result": result}

# ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π tracking data
@router.get("/schedule/tracking/{schedule_id}")
async def get_schedule_tracking(schedule_id: str):
    """‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• tracking ‡∏Ç‡∏≠‡∏á schedule"""
    sent_users = list(message_scheduler.sent_tracking.get(schedule_id, set()))
    return {
        "schedule_id": schedule_id,
        "sent_users": sent_users,
        "count": len(sent_users)
    }

# ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö reset tracking
@router.post("/schedule/reset-tracking/{schedule_id}")
async def reset_schedule_tracking(schedule_id: str):
    """Reset tracking data ‡∏Ç‡∏≠‡∏á schedule"""
    message_scheduler.sent_tracking[schedule_id] = set()
    return {"status": "success", "message": f"Reset tracking for schedule {schedule_id}"}

@router.get("/schedule/system-status")
async def get_system_status():
    """‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö scheduler"""
    return {
        "is_running": message_scheduler.is_running,
        "active_pages": list(message_scheduler.active_schedules.keys()),
        "total_schedules": sum(len(schedules) for schedules in message_scheduler.active_schedules.values()),
        "schedules_by_page": {
            page_id: len(schedules) 
            for page_id, schedules in message_scheduler.active_schedules.items()
        },
        "tracking_info": {
            schedule_id: len(users) 
            for schedule_id, users in message_scheduler.sent_tracking.items()
        }
    }