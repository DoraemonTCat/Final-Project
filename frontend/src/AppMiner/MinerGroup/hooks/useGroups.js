// MinerGroup/hooks/useGroups.js
import { useState, useEffect } from 'react';
import { getPageDbId } from '../utils/helpers';
import { getPageCustomerTypeKnowledge } from '../../../Features/Tool';

/**
 * useGroups Hook
 * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ state ‡πÅ‡∏•‡∏∞ logic ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
 * - ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏à‡∏≤‡∏Å API (‡∏£‡∏ß‡∏° knowledge types)
 * - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç/‡∏•‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°
 * - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°
 */
export const useGroups = (selectedPage) => {
  const [customerGroups, setCustomerGroups] = useState([]);
  const [selectedGroups, setSelectedGroups] = useState([]);
  const [loading, setLoading] = useState(false);
  const [editingGroupId, setEditingGroupId] = useState(null);
  const [knowledgeGroups, setKnowledgeGroups] = useState([]); // ‡πÄ‡∏û‡∏¥‡πà‡∏° state ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö knowledge groups

  const fetchCustomerGroups = async (pageId) => {
    setLoading(true);
    try {
      const dbId = await getPageDbId(pageId);
      if (!dbId) {
        setCustomerGroups([]);
        return;
      }

      // 1. ‡∏î‡∏∂‡∏á knowledge types ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö page ‡∏ô‡∏µ‡πâ
      let knowledgeTypes = [];
      try {
        const knowledgeData = await getPageCustomerTypeKnowledge(pageId);
        console.log('Knowledge data received:', knowledgeData); // ‡πÄ‡∏û‡∏¥‡πà‡∏° debug log
        
        knowledgeTypes = knowledgeData.map(kt => ({
          ...kt,
          id: kt.id || `knowledge_${kt.knowledge_id}`, // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ id format ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
          type_name: kt.type_name,
          name: kt.type_name, // ‡πÄ‡∏û‡∏¥‡πà‡∏° name field
          isKnowledge: true,
          icon: getKnowledgeIcon(kt.type_name),
          created_at: kt.created_at || new Date().toISOString(),
          customer_count: kt.customer_count || 0,
          is_active: kt.is_enabled !== false,
          message_count: 0,
          rule_description: kt.rule_description || '',
          keywords: kt.keywords || '',
          examples: kt.examples || ''
        }));
        
        console.log('Formatted knowledge types:', knowledgeTypes); // ‡πÄ‡∏û‡∏¥‡πà‡∏° debug log
        setKnowledgeGroups(knowledgeTypes);
      } catch (error) {
        console.error('Error fetching knowledge types:', error);
        knowledgeTypes = [];
      }

      // 2. ‡∏î‡∏∂‡∏á user groups (‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°)
      const response = await fetch(`http://localhost:8000/customer-groups/${dbId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch customer groups');
      }
      
      const data = await response.json();
      
      const formattedGroups = await Promise.all(data.map(async group => {
        const messageCount = await getGroupMessageCount(pageId, group.id);
        
        return {
          id: group.id,
          type_name: group.type_name,
          isDefault: false,
          isKnowledge: false, // ‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà knowledge type
          rule_description: group.rule_description || '',
          keywords: Array.isArray(group.keywords) ? group.keywords.join(', ') : group.keywords || '',
          examples: Array.isArray(group.examples) ? group.examples.join('\n') : group.examples || '',
          created_at: group.created_at,
          customer_count: group.customer_count || 0,
          is_active: group.is_active !== false,
          message_count: messageCount
        };
      }));
      
      // 3. ‡∏£‡∏ß‡∏° knowledge types ‡πÅ‡∏•‡∏∞ user groups
      const allGroups = [...knowledgeTypes, ...formattedGroups];
      setCustomerGroups(allGroups);
      
    } catch (error) {
      console.error('Error fetching customer groups:', error);
      setCustomerGroups([]);
    } finally {
      setLoading(false);
    }
  };

  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î icon ‡∏ï‡∏≤‡∏° type name
  const getKnowledgeIcon = (typeName) => {
    const iconMap = {
      '‡∏´‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏á‡∏´‡∏≤‡∏¢': 'üíî',
      '‡∏´‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏∑‡∏ô‡∏î‡∏µ': '‚ù§Ô∏è',
      '‡∏´‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏°‡πà‡∏î‡∏µ': 'üí¢',
      '‡∏´‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏∑‡∏°': 'üòå',
      '‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•': '‚ùì',
      '‡∏™‡∏ô‡πÉ‡∏à‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤': 'üõí',
      '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠': 'üìû',
      '‡∏£‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô': 'üò§',
      '‡∏ä‡∏∑‡πà‡∏ô‡∏ä‡∏°': 'üëç',
      '‡∏≠‡∏∑‡πà‡∏ô‡πÜ': 'üìå'
    };
    return iconMap[typeName] || 'üìã';
  };

  const getGroupMessageCount = async (pageId, groupId) => {
    try {
      const dbId = await getPageDbId(pageId);
      if (!dbId) return 0;
      
      const response = await fetch(`http://localhost:8000/group-messages/${dbId}/${groupId}`);
      if (!response.ok) return 0;
      
      const messages = await response.json();
      return messages.length;
    } catch (error) {
      console.error('Error getting message count:', error);
      return 0;
    }
  };

  const toggleGroupSelection = (groupId) => {
    setSelectedGroups(prev => {
      if (prev.includes(groupId)) {
        return prev.filter(id => id !== groupId);
      }
      return [...prev, groupId];
    });
  };

  useEffect(() => {
    if (selectedPage) {
      fetchCustomerGroups(selectedPage);
      setSelectedGroups([]);
    } else {
      setCustomerGroups([]);
      setSelectedGroups([]);
    }
  }, [selectedPage]);

  return {
    customerGroups,
    selectedGroups,
    loading,
    editingGroupId,
    setEditingGroupId,
    toggleGroupSelection,
    fetchCustomerGroups,
    knowledgeGroups // export knowledge groups ‡πÅ‡∏¢‡∏Å
  };
};